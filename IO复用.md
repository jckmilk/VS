##I/O 复用

预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件准备就绪，它就通知进程。

I/O复用使用的应用场合
- 当客户处理多个描述符时（交互输入和网络套接字),必须使用I/O复用。
- 一个客户同时处理多个套接字。
- 一个TCP服务器既要处理监听套接字，又要处理已连接套接字。
- 一个服务器既要处理tcp，又要处理udp。

##I/O模型
- 阻塞式I/O
- 非阻塞I/O
- I/O复用(select和poll）
- 信号驱动I/O
- 异步I/O

一个输入操作包含两个阶段：
(1)等待数据准备好
(2)从内核向进程复制数据
第一步涉及等待数据从网络中到达，当所等待的分组到达时，它被复制到内核的某个缓冲区。第二部就是将数据从内核缓冲区复制到应用进程缓冲区。

##阻塞I/O

##非阻塞I/O

进程把一个套接字设置成非阻塞是通知内核：当所请求的I/O操作非得把本进程投入睡眠才能完成，不要把本进程投入睡眠，而是返回一个错误。  

比如轮询调用，耗费大量CPU时间。

##I/O复用

堵塞在select和poll这两个系统调用上，而不是阻塞在真正的I/O系统调用上。
select的优势在于我们可以等待多个描述符就绪。

##信号驱动式IO

使用信号，让内核在描述符就绪时发送sigio信号通知。

##异步I/O

工作机制:告诉内核启动某个操作，并让内核在整个操作完成后通知我们。
与信号驱动模型的区别在于：信号确定是内核通知我们何时启动一个I/O操作。而异步是内核通知我们I/O何时完成。

##各种I/O的比较

同步I/O：导致请求进程阻塞，知道I/O操作完成
异步I/O：不导致请求进程阻塞。

##selec函数

该函数允许进程指示内核等待多个事件中的任何一个发生，并且在有一个或多个事件发生或经历一段指定的时间后才唤醒它。

    int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
    若有就绪描述符则为其数目，超时则为0，出错则为-1
    
timeout告诉内核等待所指定描述符中任何一个就绪可花多长时间。
这个参数有以下三种可能。
(1)永远等待下去，参数设置为NULL
(2)等待一段固定时间
(3)不等待：检查描述符后直接返回。定时器值必须为0；

中间三个参数指定我们要让内核测试读，写。异常条件的描述符。
如何给这三个参数中每个参数指定一个或多个描述符时一个设计上的问题。select使用描述符集，通常是一个整数数组。每个整数的每一位对应一个描述符。

##描述符就绪条件
select返回套接字就绪的条件
(1)满足下列四个条件之一，一个套接字准备好读。
a)该套接字接收缓冲区中的数据字节大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并返回一个大于0的值。
b）该连接的读半部关闭(接收到了FIN的tcp连接），对这样的套接字的读操作将不阻塞并返回0。
c）该套接字是一个监听套接字且已完成的连接数部位0，对这样的套接字accept通常不会阻塞
d)其上一个套接字错误待处理。对这样的套接字的读操作将不阻塞并返回-1。
(2)满足下列四个条件之一，一个套接字准备好写。
(3)

##select的最大描述符数




