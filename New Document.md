
##POSIX信号量

信号就是告诉某个进程发生了某个事件的通知，有时也成为软件中断。信号通常是异步发生的。也就是进程预先不知道信号的准确发送时刻。

信号可以：
- 由一个进程发给另一个进程（或自身）
- 由内核发给某个进程

每个信号都有一个与之关联的处置，也称为行为。我们通过调用sigaction函数来设定一个信号的处置，并有三种选择。
(1) 提供一个函数，只要有特定信号发生它就被调用。函数交信号处理函数，行为成为捕获信号，有两个信号不能被捕获，SIGKILL和STGSTOP。信号处理函数由信号值这一个单一的整数参数来调用，且没有返回值

    void handler（int signo）;
大多数信号 调用sigaction函数并指定信号发生所调用的函数。但sigio，sigppll和sigurg还需要其他额外工作。
(2)把某个信号的处置设定为SIG_IGN来忽略。sigkill和stgstop不可以被忽略。
(3)某个信号设置为SIG_IGN来启用默认。默认处置通产是在收到信号后终止进程，其中某些信号还在当前目录产生一个进程的核心镜像。

##signal函数

建立信号处置的POSIX方法就是调用sigaction函数。

    signal函数,第一个参数为信号名，第二个参数或为指向函数的指针，或为常值 SIG_IGN或SIG_DFL.

POSIX信号语义
- 一旦安装信号处理函数一直安装
- 在一个信号处理函数运行期间，正被递交的信号是阻塞的。。并且，安装处理函数时在传递给signation函数的sa_mask信号指定的额外信号也被阻塞。
- 如果一个信号被阻塞期间产生一次或多次，那么该信号被解阻塞之后通常只递交一次，也就是unix信号默认是不排队的。
- 利用sigprocmask函数选择性的阻塞或解阻塞一组信号是可能的。

##处理SIGCHLD信号

设置僵死状态的目的是维护子进程的信息，以便父进程在以后某个时候获取，包括子进程的ID，终止状态，以及资源利用信息。如果一个进程终止而子进程处于僵死状态，则僵死子进程的父进程ID重置为1（init进程）。init进程将清理它们。

处理僵死进程

fork之后需要wait它们，以防止它们变成僵死进程。为此我们建立一个俘获sigchld信号的信号处理函数，然后调用wait()函数。
信号处理函数在fork之前建立且只做一次。

##处理被中断的系统调用

##wait和waitpid函数

    pid_t wait(int *statloc);
    pid_t waitpid(pid_t pid, int *statloc, int options);
    成功返回进程IF，出错返回0或-1；
wait和waitpid均返回两个值:已终止的子进程IF，以及statloc指针返回的子进程终止状态。通过三个宏检查子进程的终止状态。

如果调用wait的进程没有已终止的子进程，但仍有子进程在执行，则wait将阻塞到有第一个子进程终止。

waitpid函数 pid可以指定进程ID，-1表示等待的第一个终止的子进程。options参数允许指定附加选项，最常用WNOHANG，它告诉内核在没有已终止子进程时不要阻塞。

##wait和waitpid的区别
建立一个信号处理函数并在其中调用wait函数并不足以防止出现僵尸进程。信号处理函数只执行一次。
正确的解决办法是调用waitpid


网络编程可能遇到的三种情况：
1. 当fork子进程时，必须捕获SIGCHLD信号；
2. 当捕获信号时，必须处理被中断的系统信号；
3. SIGHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程。

##accept返回前连接终止

三次握手完成建立连接之后，客户端tcp却发送一个RST。

##服务器进程终止？？？

找到子进程ID，然后执行kill命令杀死，这导致子进程的描述符关闭，向客户端发送一个FIN，





